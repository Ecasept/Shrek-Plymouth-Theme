
#Window.SetBackgroundTopColor(0.141, 0.141, 0.141);
#Window.SetBackgroundBottomColor(0.141, 0.141, 0.9);

shrekImage = Image("shrek.png");
logoImage = Image("logo.png");
logoImage = logoImage.Scale(logoImage.GetWidth() * 0.25, logoImage.GetHeight() * 0.25);

shreksPerColumn = 5;

targetShrekHeight = Window.GetHeight() / shreksPerColumn;
scaleFactor = targetShrekHeight / shrekImage.GetHeight();
shrekImage = shrekImage.Scale(targetShrekHeight, shrekImage.GetWidth() * scaleFactor);


shreksPerRow = Math.Int(Window.GetWidth() / shrekImage.GetWidth());
horizontalExtraSpace = (Window.GetWidth() % shrekImage.GetWidth());
horizontalSpacing = horizontalExtraSpace / (shreksPerRow - 1);














fadeTime = 2;
logoTime = 2;

spiralFinished = 0;

# Every item needs a reference(or it will be deleted), so save every created shrek sprite
shreks = [];
shrekCount = 0;


debug = Sprite();
debug.SetPosition(Window.GetWidth() / 2, Window.GetHeight() / 2, 100);
fun log(msg) {
    debug.SetImage(Image.Text(msg, 255, 255, 255));
}

fun Shrek(creationTime) {
    newShrek = [];
    newShrek.creationTime = creationTime;
    newShrek.sprite = Sprite(shrekImage);
    return newShrek;
}


fun centerSprite(sprite) {
    sprite.SetX(Window.GetWidth() / 2 - sprite.GetImage().GetWidth() / 2);
    sprite.SetY(Window.GetHeight() / 2 - sprite.GetImage().GetHeight() / 2);
}

fun ceil(num) {
    return Math.Int(num + 0.5);
}

fun addShrek(time) {
    width = shrekImage.GetWidth();
    height = shrekImage.GetHeight();

    index = shrekCount;
    shrekCount++;

    shreks[index] = Shrek(time);
    shreks[index].sprite.SetImage(shrekImage);

    nextTile();
    shreks[index].sprite.SetPosition(cX * width + cX * horizontalSpacing, cY * height, 10);
    shreks[index].sprite.SetOpacity(0);

    # Check if last shrek
    if (cX == ceil(shreksPerRow / 2) - 1 && cY == ceil(shreksPerColumn / 2) - 1) {
        spiralFinished = 1;
    }

    if (spiralFinished) {
        # last shrek

        # Fade in
        Animation(shreks[index].sprite, time, fadeTime / 2, 0, 1, quadraticOut, fun(sprite, val) {
            sprite.SetOpacity(val);
        }, fun(sprite, time) {
            # Wait
            Animation(sprite, time, fadeTime / 2, 1, 1, linear, fun(sprite, val) {
                # Do nothing
            }, fun(sprite, time) {
                animateLogo(time);
            });
        });
    } else {
        # other shreks

        # Fade in
        Animation(shreks[index].sprite, time, fadeTime / 2, 0, 1, quadraticOut, fun(sprite, val) {
            sprite.SetOpacity(val);
        }, fun(sprite, time) {
            # Fade out
            Animation(sprite, time, fadeTime / 2, 1, 0, quadraticIn, fun(sprite, val) {
                sprite.SetOpacity(val);
            }, fun(sprite, time) {
                
            });
        });
    }
    # TODO:   extra check: w >= h
}

# Spiral Traversal
left = 0;
right = shreksPerRow - 1;
top = 0;
bottom = shreksPerColumn - 1;

dir = "r";
cX = -1;
cY = 0;
fun nextTile() {
    if (dir == "r") {
        cX++;
        if (cX == right) {
            top++;
            dir = "d";
        }
    }
    else if (dir == "l") {
        cX--;
        if (cX == left) {
            bottom--;
            dir = "u";
        }
    }
    else if (dir == "u") {
        cY--;
        if (cY == top) {
            left++;
            dir = "r";
        }
    }
    else if (dir == "d") {
        cY++;
        if (cY == bottom) {
            right--;
            dir = "l";
        }
    }
}

logoAnimStart = -1;
logoSprite = Sprite();
logoSprite.SetImage(logoImage);
logoSprite.SetOpacity(1);

lastShrekXTile = ceil(shreksPerRow / 2) - 1;
lastShrekPos = lastShrekXTile * shrekImage.GetWidth() + lastShrekXTile * horizontalSpacing;
logoStartXPos = lastShrekPos + shrekImage.GetWidth() - logoImage.GetWidth();
logoSprite.SetPosition(logoStartXPos, Window.GetHeight() / 2 - logoImage.GetHeight() / 2, -11);


# shrekImage and logoImage are next to each other and should be in the middle
combinedWidth = shrekImage.GetWidth() + logoImage.GetWidth();
combinedMiddle = Window.GetWidth() / 2 - combinedWidth / 2;

logoEndX = combinedMiddle + shrekImage.GetWidth();
shrekEndX = combinedMiddle;

blackImage = Image("black.png");
blackRightEdgePos = lastShrekPos + shrekImage.GetWidth();
blackPos = blackRightEdgePos - blackImage.GetWidth();
blackSprite = Sprite(blackImage);
blackSprite.SetPosition(blackPos, 0, -10);
blackSprite.SetOpacity(1);

fun animateLogo(time) {
    # Animate logo to the right
    Animation(logoSprite, time, logoTime, logoStartXPos, logoEndX, quadraticInOut, fun(sprite, val) {
        sprite.SetX(val);
    }, fun(sprite, time) {
        # TODO:
    });
    # Animate shrek to the left
    Animation(shreks[shrekCount - 1].sprite, time, logoTime, lastShrekPos, shrekEndX, quadraticInOut, fun(sprite, val) {
        sprite.SetX(val);
    }, fun(sprite, time) {});
    # Animate black to the left
    offset = lastShrekPos - shrekEndX; # Animate the same as shrek
    Animation(blackSprite, time, logoTime, blackPos, blackPos - offset, quadraticInOut, fun(sprite, val) {
        sprite.SetX(val);
    }, fun(sprite, time) {});
}

iterations = 0;
tickStep = 0.17;
lastTick = 1;

fun progress_callback(time, progress) {
    animationTick(time);
    printProgress(time, progress);
    if (time - lastTick >= tickStep && !spiralFinished) {
        addShrek(time);
        iterations++;
        lastTick += tickStep;
    }
}
Plymouth.SetBootProgressFunction(progress_callback);


# =============================================
# ------------- Animation Engine --------------
# =============================================


fun lerp(start, end, progress, ease) {
    return start + (end - start) * ease(progress);
}
fun linear(val) {
    return val;
}
fun flip(val) {
    return 1 - val;
}
fun quadraticIn(val) {
    return val * val;
}
fun quadraticOut(val) {
    return flip(quadraticIn(flip(val)));
}
fun quadraticInOut(x) {
    return lerp(quadraticIn(x), quadraticOut(x), x, linear);
}



animObjects = [];
animObjectsLength = 0;

# -------- Animation Tick for all animations ----------
fun animationTick(time) {
    for (local.i = 0; local.i < animObjectsLength; local.i++) {
        animObjects[local.i].tick(time);
    }
}

# --------------- Constructor -----------------
Animation = fun(target, startTime, duration, start, end, easing, tickCallback, endCallback) {
    newAnim = [] | global.Animation;
    newAnim.target = target;
    newAnim.startTime = startTime;
    newAnim.duration = duration;
    newAnim.easing = easing;
    newAnim.tickCallback = tickCallback;
    newAnim.endCallback = endCallback;
    newAnim.start = start;
    newAnim.end = end;

    newAnim.hasEnded = 0;

    animObjects[animObjectsLength] = newAnim;
    animObjectsLength++;

    return newAnim;
} | [];

# --------------- Animation Tick -----------------
Animation.tick = fun(time) {
    if (this.hasEnded) {
        return;
    }

    existenceTime = time - this.startTime;
    progress = existenceTime / this.duration;

    val = lerp(this.start, this.end, progress, this.easing);

    this.tickCallback(target, val);
    if (existenceTime > this.duration) {
        this.endCallback(target, time);
        this.hasEnded = 1;
    }

};
